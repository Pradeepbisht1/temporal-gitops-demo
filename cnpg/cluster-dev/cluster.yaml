apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: temporal-pg
  namespace: postgres-temporal
spec:
  instances: 3
  imageName: ghcr.io/cloudnative-pg/postgresql:16.4
  primaryUpdateStrategy: unsupervised

  storage:
    size: 20Gi
    # storageClass: gp3   # <- uncomment if needed

  enableSuperuserAccess: true
  superuserSecret:
    name: temporal-pg-superuser

  bootstrap:
    initdb:
      dataChecksums: true
      encoding: "UTF8"
      localeCType: "en_US.UTF-8"
      localeCollate: "en_US.UTF-8"

  monitoring:
    enablePodMonitor: false

  # === SCHEDULING FIXES ===
  # Prefer/force scheduling on EC2 nodes (if your NodePool sets this label)
  nodeSelector:
    eks.amazonaws.com/compute-type: "ec2"

  # Tolerate Karpenter disruption taint; do NOT tolerate Fargate taint
  tolerations:
    - key: "karpenter.sh/disrupted"
      operator: "Exists"
      effect: "NoSchedule"

  affinity:
    # Keep CNPG's anti-affinity preference (spread replicas)
    podAntiAffinityType: preferred

    # Hard rule: never land on Fargate
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: eks.amazonaws.com/compute-type
                operator: NotIn
                values: ["fargate"]

  resources:
    requests:
      cpu: "500m"
      memory: "1Gi"
    limits:
      cpu: "1"
      memory: "2Gi"

  # Services:
  # - temporal-pg-rw.postgres-temporal.svc.cluster.local (primary RW)
  # - temporal-pg-ro.postgres-temporal.svc.cluster.local (read-only)
