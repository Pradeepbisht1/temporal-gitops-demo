apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: temporal-pg
  namespace: postgres-temporal
  annotations:
    # CNPG CRD/webhook fully ready hone se pehle Argo dry-run skip kare
    argocd.argoproj.io/sync-options: SkipDryRunOnMissingResource=true
    # (optional) App-of-Apps me order control
    argocd.argoproj.io/sync-wave: "1"
spec:
  instances: 3
  imageName: ghcr.io/cloudnative-pg/postgresql:16.4
  primaryUpdateStrategy: unsupervised

  storage:
    size: 20Gi
    # storageClass: gp3   # <- agar default SC sahi nahi hai to uncomment

  enableSuperuserAccess: true
  superuserSecret:
    name: temporal-pg-superuser

  bootstrap:
    initdb:
      dataChecksums: true
      encoding: "UTF8"
      localeCType: "en_US.UTF-8"
      localeCollate: "en_US.UTF-8"

  monitoring:
    enablePodMonitor: false

  # === Scheduling ===
  # Prefer/force EC2 nodes if NodePool ye label deta hai
  nodeSelector:
    eks.amazonaws.com/compute-type: "ec2"

  # Avoid Fargate; Karpenter disruption ko tolerate karo
  tolerations:
    - key: "karpenter.sh/disrupted"
      operator: "Exists"
      effect: "NoSchedule"

  affinity:
    # replicas ko spread karne ke liye
    podAntiAffinityType: preferred
    # Hard rule: Fargate pe kabhi schedule na ho
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: eks.amazonaws.com/compute-type
                operator: NotIn
                values: ["fargate"]

  resources:
    requests:
      cpu: "500m"
      memory: "1Gi"
    limits:
      cpu: "1"
      memory: "2Gi"

  # Services:
  # - temporal-pg-rw.postgres-temporal.svc.cluster.local (primary RW)
  # - temporal-pg-ro.postgres-temporal.svc.cluster.local (read-only)
